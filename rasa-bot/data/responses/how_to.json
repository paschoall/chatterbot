{
    "all nodes": "To create a test set using the all-nodes criterion for your program, you first need to draw the CFG of it (ask me how to do that if you don\u2019t know yet). Then you have to analyse, for each node of your program, what your input must look like so that this node is executed. For example, if you have an if statement such as ```if(A > 0) print(\u2018A is positive); ``` in your program, you know that the node corresponding to the ```print``` command will only be executed when ```A``` is positive, and so you must insert at least one test case as such. More complex programs will require a deeper analysis, which most of the times will involve more mathematics skills than software testing ones.",
    "all edges": "To create a test set using the all-edges criterion for your program, you first need to draw the CFG of it (ask me how to do that if you don\u2019t know yet). Then, one approach for generating the test set is to analyse, for each branch of the CFG, what the input must look like so that this branch is executed. For example, if you have an IF statement such as ```if(strlen(s) == 0) break;```, you must consider at least one test case where ```s``` is empty and the edge corresponding to this ```break``` statement will be exercised. However, this approach may be difficult and require very deep analysis for complex programs and algorithms.",
    "cyclomatic complexity": "To create a test set using the McCabe criterion, first write down a complete path always making decisions in predicate nodes to avoid loops (or the first path could be the result of a random real input). Then, the following paths should be equal to the previous one, but changing the decision of the first predicate node not changed yet. After you cannot add any more paths, you have exactly C paths, where C is the McCabe complexity of your CFG. You should create test cases the exercise this paths. This test set also has the property that it satisfies statement coverage and branch coverage criterions.",
    "control flow graph": "The control flow graph is very easy to create. The CFG of a sequential program with no control flow deviations is simply a single node. In a more complex program, with loops and conditional statements, the graph gains some edges, but you are able to draw any CFG if you are able to represent usual components of programs, like IFs, WHILEs and so. Ask me how to represent that.",
    "functional testing": "It depends of the functional testing criterion used. The most common criteria used in functional testing are equivalence partitioning and boundary-value analysis. Please, ask me how to use equivalence partitioning criterion and/or boundary-value analysis criterion",
    "equivalence partitioning": "The equivalence partitioning criterion divides the input domain in several subsets (partitions) with no intersection and selects a test case for each partition. The idea is that each test case represents all input domain that partition class and, therefore, one test case for each class is enough for this testing criterion. The criterion considers valid and invalid equivalence classes. For example, you can separate invalid and valid inputs into two different subsets or classes.",
    "boundary value": "The boundary-value testing criterion determines the boundaries for input values and selects the extremes of the boundary to generate test cases. For instance, if a program's valid input is a positive number less than 10, then the following test cases will be selected in order to test the boundaries: 0, 1, -1, 10, 9 and 11."
}